This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

## Additional Info

# Directory Structure
```
docs/
  algorithm_details.md
include/
  compression/
    huffman.h
  encryption/
    chacha20.h
  utils/
    cli_utils.h
    file_utils.h
src/
  compression/
    huffman.c
    utils.c
  encryption/
    chacha20.c
  utils/
    cli_utils.c
    file_utils.c
  main.c
test/
  test_compression.c
  test_encryption.c
.gitignore
makefile
```

# Files

## File: docs/algorithm_details.md
```markdown
# Algorithm Details 
This document contains detailed descriptions of the implemented algorithms.
```

## File: include/compression/huffman.h
```
#ifndef HUFFMAN_H 
#define HUFFMAN_H 
// Huffman compression/decompression functions 
void compress_huffman(const char *input, char *output); 
void decompress_huffman(const char *input, char *output); 
#endif
```

## File: include/encryption/chacha20.h
```
/**
 * chacha20.h - Header file for ChaCha20 stream cipher implementation
 * 
 * This header file provides the function prototypes and structures
 * for a ChaCha20 stream cipher implementation according to RFC 8439.
 * (https://datatracker.ietf.org/doc/html/rfc8439)
 * 
 * ChaCha20 is a stream cipher developed by Daniel J. Bernstein that
 * uses a 256-bit key and a 96-bit nonce to generate a keystream that
 * is XORed with the plaintext to produce ciphertext.
 * 
 * Allowed libraries: stdio.h, stdlib.h, string.h, math.h
 */

#ifndef CHACHA20_H
#define CHACHA20_H

#include <stdint.h>  /* For uint32_t, uint8_t */
#include <stddef.h>  /* For size_t */

/* --- Constants --- */
#define CHACHA20_KEY_SIZE 32    /* 256 bits */
#define CHACHA20_NONCE_SIZE 12  /* 96 bits (as per RFC 8439) */
#define CHACHA20_BLOCK_SIZE 64  /* 512 bits */
#define CHACHA20_ROUNDS 20      /* Number of rounds in ChaCha20 */

/**
 * ChaCha20 context structure
 * Holds the state of the cipher during encryption/decryption
 */
typedef struct {
    uint32_t state[16];              /* ChaCha20 state (4x4 matrix) */
    uint8_t keystream[CHACHA20_BLOCK_SIZE]; /* Generated keystream buffer */
    size_t position;                 /* Current position in keystream */
} chacha20_ctx;

/**
 * Initialize the ChaCha20 context with key, nonce, and counter
 * 
 * Sets up the initial 4x4 matrix state according to RFC 8439:
 * - constants (4 words): "expand 32-byte k" in ASCII
 * - key (8 words): 256-bit key
 * - counter (1 word): Block counter (usually 0 or 1)
 * - nonce (3 words): 96-bit nonce
 * 
 * @param ctx     Pointer to the chacha20_ctx structure to initialize
 * @param key     256-bit key (32 bytes)
 * @param nonce   96-bit nonce (12 bytes)
 * @param counter Initial counter value (usually 0 or 1)
 * @return        0 on success, -1 on failure (NULL pointers)
 */
int chacha20_init(chacha20_ctx *ctx, const uint8_t *key, const uint8_t *nonce, uint32_t counter);

/**
 * Process (encrypt or decrypt) data using ChaCha20
 * Note: ChaCha20 is symmetric, so the same function is used for both operations
 * 
 * This function XORs the input data with the keystream generated by ChaCha20.
 * It manages the keystream buffer, generating new blocks as needed.
 * 'input' and 'output' can point to the same buffer for in-place processing.
 * 
 * @param ctx       Pointer to the initialized chacha20_ctx structure
 * @param input     Input data (plaintext or ciphertext)
 * @param output    Output buffer (must be at least as large as input_len)
 * @param input_len Length of the input data in bytes
 * @return          0 on success, -1 on failure (NULL pointers or invalid parameters)
 */
int chacha20_process(chacha20_ctx *ctx, const uint8_t *input, uint8_t *output, size_t input_len);

/**
 * Generate a new block of keystream
 * This is an internal function used by chacha20_process
 * 
 * This function performs 20 rounds of ChaCha20 operations on the state
 * to produce a 64-byte keystream block, stores it in the context's
 * keystream buffer, and increments the block counter in the state.
 * 
 * @param ctx Pointer to the chacha20_ctx structure
 * @return    0 on success, -1 on failure
 */
int chacha20_block(chacha20_ctx *ctx);

/**
 * Helper function to perform the ChaCha20 quarter round operation
 * 
 * @param a Index of first state word
 * @param b Index of second state word
 * @param c Index of third state word
 * @param d Index of fourth state word
 * @param state The state array to modify
 */
void chacha20_quarterround(int a, int b, int c, int d, uint32_t *state);

/**
 * Zero sensitive data in memory to prevent leakage
 * This should be called when the context is no longer needed
 * 
 * @param ctx Pointer to the chacha20_ctx structure to clear
 */
void chacha20_cleanup(chacha20_ctx *ctx);

#endif /* CHACHA20_H */
```

## File: include/utils/cli_utils.h
```
#ifndef CLI_UTILS_H 
#define CLI_UTILS_H 
// Command-line interface utility functions 
#endif
```

## File: include/utils/file_utils.h
```
#ifndef FILE_UTILS_H 
#define FILE_UTILS_H 
// File handling utility functions 
#endif
```

## File: src/compression/huffman.c
```cpp
// Huffman compression implementation
```

## File: src/compression/utils.c
```cpp
// Compression utility functions
```

## File: src/encryption/chacha20.c
```cpp
/**
 * chacha20.c - Implementation of the ChaCha20 stream cipher
 * 
 * This file implements the ChaCha20 stream cipher as defined in RFC 8439.
 * https://datatracker.ietf.org/doc/html/rfc8439
 * 
 * Only uses the following standard C libraries as required:
 * - stdio.h (only used in debug mode)
 * - stdlib.h (not used in this file)
 * - string.h (for memcpy, memset)
 * - math.h (not used in this file)
 */

#include "encryption/chacha20.h"
#include <string.h>  /* For memcpy, memset */

/* Debug printing support */
#ifdef CHACHA20_DEBUG
#include <stdio.h> /* For printf in debug mode */
#define DEBUG_PRINT(...) printf("[ChaCha20] " __VA_ARGS__)
#define DEBUG_PRINT_STATE(label, state) debug_print_state(label, state)
#define DEBUG_PRINT_BYTES(label, bytes, len) debug_print_bytes(label, bytes, len)
#else
#define DEBUG_PRINT(...)
#define DEBUG_PRINT_STATE(label, state)
#define DEBUG_PRINT_BYTES(label, bytes, len)
#endif

/* Helper macros for ChaCha20 */
#define ROTL32(v, c) (((v) << (c)) | ((v) >> (32 - (c))))
#define U32TO8_LITTLE(p, v) \
    (p)[0] = (uint8_t)((v)); \
    (p)[1] = (uint8_t)((v) >> 8); \
    (p)[2] = (uint8_t)((v) >> 16); \
    (p)[3] = (uint8_t)((v) >> 24);

#define U8TO32_LITTLE(p) \
    (((uint32_t)((p)[0])) | \
     ((uint32_t)((p)[1]) << 8) | \
     ((uint32_t)((p)[2]) << 16) | \
     ((uint32_t)((p)[3]) << 24))

/* ChaCha20 constants - "expand 32-byte k" in ASCII */
static const uint32_t CHACHA20_CONSTANTS[4] = {
    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574
};

#ifdef CHACHA20_DEBUG
/* Debug helper function to print state matrix */
static void debug_print_state(const char *label, const uint32_t *state) {
    printf("[ChaCha20] %s:\n", label);
    for (int i = 0; i < 4; i++) {
        printf("[ChaCha20]   ");
        for (int j = 0; j < 4; j++) {
            printf("0x%08x ", state[i * 4 + j]);
        }
        printf("\n");
    }
}

/* Debug helper function to print byte array */
static void debug_print_bytes(const char *label, const uint8_t *bytes, size_t len) {
    printf("[ChaCha20] %s: ", label);
    for (size_t i = 0; i < len && i < 32; i++) { /* Limit to first 32 bytes */
        printf("%02x", bytes[i]);
        if ((i + 1) % 4 == 0) printf(" ");
    }
    if (len > 32) printf("... (%zu bytes total)", len);
    printf("\n");
}
#endif

void chacha20_quarterround(int a, int b, int c, int d, uint32_t *state) {
    /* Implements the ChaCha20 quarter round function */
    state[a] += state[b]; state[d] ^= state[a]; state[d] = ROTL32(state[d], 16);
    state[c] += state[d]; state[b] ^= state[c]; state[b] = ROTL32(state[b], 12);
    state[a] += state[b]; state[d] ^= state[a]; state[d] = ROTL32(state[d], 8);
    state[c] += state[d]; state[b] ^= state[c]; state[b] = ROTL32(state[b], 7);
}

int chacha20_block(chacha20_ctx *ctx) {
    uint32_t x[16];
    int i;
    
    if (ctx == NULL) {
        return -1;
    }
    
    DEBUG_PRINT("Generating block for counter: %u\n", ctx->state[12]);
    DEBUG_PRINT_STATE("Initial state", ctx->state);
    
    /* Create a copy of the current state */
    memcpy(x, ctx->state, 64);
    
    /* Apply 20 rounds of ChaCha20 (10 column rounds + 10 diagonal rounds) */
    for (i = 0; i < 10; i++) {
        /* Column rounds */
        chacha20_quarterround(0, 4, 8, 12, x);
        chacha20_quarterround(1, 5, 9, 13, x);
        chacha20_quarterround(2, 6, 10, 14, x);
        chacha20_quarterround(3, 7, 11, 15, x);
        
        /* Diagonal rounds */
        chacha20_quarterround(0, 5, 10, 15, x);
        chacha20_quarterround(1, 6, 11, 12, x);
        chacha20_quarterround(2, 7, 8, 13, x);
        chacha20_quarterround(3, 4, 9, 14, x);
        
        DEBUG_PRINT("After round %d\n", (i * 2) + 2);
    }
    
    DEBUG_PRINT_STATE("After 20 rounds", x);
    
    /* Add the original state to the result */
    for (i = 0; i < 16; i++) {
        x[i] += ctx->state[i];
    }
    
    DEBUG_PRINT_STATE("After final addition", x);
    
    /* Convert to little-endian bytes and store in keystream */
    for (i = 0; i < 16; i++) {
        U32TO8_LITTLE(ctx->keystream + (i * 4), x[i]);
    }
    
    DEBUG_PRINT_BYTES("Generated keystream", ctx->keystream, CHACHA20_BLOCK_SIZE);
    
    /* Increment counter for next block and handle overflow */
    ctx->state[12]++;
    if (ctx->state[12] == 0) {
        /* Counter overflow - increment the next word */
        ctx->state[13]++;
        DEBUG_PRINT("WARNING: Counter overflow, incrementing next word\n");
    }
    
    /* Reset position in keystream */
    ctx->position = 0;
    
    /* Clear sensitive data from the stack */
    memset(x, 0, sizeof(x));
    
    return 0;
}

int chacha20_init(chacha20_ctx *ctx, const uint8_t *key, const uint8_t *nonce, uint32_t counter) {
    int i;
    
    if (ctx == NULL || key == NULL || nonce == NULL) {
        return -1;
    }
    
    DEBUG_PRINT("Initializing ChaCha20 with counter=%u\n", counter);
    DEBUG_PRINT_BYTES("Key", key, CHACHA20_KEY_SIZE);
    DEBUG_PRINT_BYTES("Nonce", nonce, CHACHA20_NONCE_SIZE);
    
    /* Set up the initial state (4x4 matrix of 32-bit words) */
    
    /* First row: ChaCha20 constants */
    ctx->state[0] = CHACHA20_CONSTANTS[0];
    ctx->state[1] = CHACHA20_CONSTANTS[1];
    ctx->state[2] = CHACHA20_CONSTANTS[2];
    ctx->state[3] = CHACHA20_CONSTANTS[3];
    
    /* Second and third rows: 256-bit key */
    for (i = 0; i < 8; i++) {
        ctx->state[4 + i] = U8TO32_LITTLE(key + (i * 4));
    }
    
    /* Fourth row: Counter and nonce */
    ctx->state[12] = counter;
    ctx->state[13] = U8TO32_LITTLE(nonce);
    ctx->state[14] = U8TO32_LITTLE(nonce + 4);
    ctx->state[15] = U8TO32_LITTLE(nonce + 8);
    
    DEBUG_PRINT_STATE("Initial state", ctx->state);
    
    /* Initialize position to force generation of first block */
    ctx->position = CHACHA20_BLOCK_SIZE;
    
    return 0;
}

int chacha20_process(chacha20_ctx *ctx, const uint8_t *input, uint8_t *output, size_t input_len) {
    size_t i;
    
    if (ctx == NULL || (input == NULL && input_len > 0) || output == NULL) {
        return -1;
    }
    
    DEBUG_PRINT("Processing %zu bytes of data\n", input_len);
    DEBUG_PRINT_BYTES("Input data (first bytes)", input, input_len > 32 ? 32 : input_len);
    
    for (i = 0; i < input_len; i++) {
        /* Generate new block if needed */
        if (ctx->position == CHACHA20_BLOCK_SIZE) {
            if (chacha20_block(ctx) != 0) {
                return -1;
            }
        }
        
        /* XOR input with keystream to produce output */
        output[i] = input[i] ^ ctx->keystream[ctx->position++];
    }
    
    DEBUG_PRINT_BYTES("Output data (first bytes)", output, input_len > 32 ? 32 : input_len);
    DEBUG_PRINT("Processing complete\n");
    
    return 0;
}

void chacha20_cleanup(chacha20_ctx *ctx) {
    if (ctx != NULL) {
        /* Zero out the entire context to prevent sensitive data leakage */
        memset(ctx->state, 0, sizeof(ctx->state));
        memset(ctx->keystream, 0, sizeof(ctx->keystream));
        ctx->position = 0;
        
        DEBUG_PRINT("Context cleared\n");
    }
}
```

## File: src/utils/cli_utils.c
```cpp
// Command-line interface utilities
```

## File: src/utils/file_utils.c
```cpp
// File handling utilities
```

## File: src/main.c
```cpp
/**
 * main.c - ChaCha20 encryption/decryption demonstration program
 * 
 * Group: [Your Group Number]
 * Lab: [Your Lab Number]
 * 
 * Compiling instructions:
 * To compile this program, use the provided makefile with the command:
 *   make
 * 
 * This will produce an executable named 'chacha20_demo'.
 * 
 * For a debug build with verbose output:
 *   make DEBUG=1
 * 
 * Alternatively, compile manually with:
 *   gcc -Wall -o chacha20_demo main.c chacha20.c
 *   
 * For debug build:
 *   gcc -Wall -DCHACHA20_DEBUG -o chacha20_demo main.c chacha20.c
 * 
 * This program demonstrates the ChaCha20 stream cipher implementation
 * according to RFC 8439 (https://datatracker.ietf.org/doc/html/rfc8439)
 * by:
 * 1. Encrypting a text message
 * 2. Decrypting it back to plaintext
 * 3. Optionally performing a file encryption/decryption based on command-line arguments
 * 
 * Only uses the following standard C libraries as required:
 * - stdio.h
 * - stdlib.h
 * - string.h
 * - math.h (not used in this file)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "encryption/chacha20.h"

/* Debug mode can be enabled via makefile (make DEBUG=1) */
#ifdef CHACHA20_DEBUG
#define DEBUG_PRINT(fmt, ...) printf("[Main] " fmt, ##__VA_ARGS__)
#define PRINT_HEX(label, data, len) print_hex(label, data, len)
#else
#define DEBUG_PRINT(fmt, ...)
#define PRINT_HEX(label, data, len)
#endif

/**
 * Print binary data in a readable hexadecimal format
 * 
 * @param label Label to print before the data
 * @param data  Data to print
 * @param len   Length of the data in bytes
 */
void print_hex(const char *label, const uint8_t *data, size_t len) {
    size_t i;
    printf("%s: ", label);
    for (i = 0; i < len; i++) {
        printf("%02x", data[i]);
        if ((i + 1) % 4 == 0) printf(" ");
    }
    printf("\n");
}

/**
 * Derive a key and nonce from a password
 * Note: This is a simplified implementation for demonstration purposes.
 * In a real application, use a proper key derivation function like PBKDF2.
 * 
 * @param password The password to derive key and nonce from
 * @param key      Output buffer for the key (32 bytes)
 * @param nonce    Output buffer for the nonce (12 bytes)
 * @return         0 on success, -1 on failure
 */
int derive_key_and_nonce(const char *password, uint8_t *key, uint8_t *nonce) {
    size_t password_len;
    size_t i;
    
    if (password == NULL || key == NULL || nonce == NULL) {
        return -1;
    }
    
    password_len = strlen(password);
    if (password_len == 0) {
        return -1;
    }
    
    DEBUG_PRINT("Deriving key and nonce from password (%zu chars)\n", password_len);
    
    /* Initialize key and nonce with zeros */
    memset(key, 0, CHACHA20_KEY_SIZE);
    memset(nonce, 0, CHACHA20_NONCE_SIZE);
    
    /* Simple password stretching (not secure, for demonstration only) */
    for (i = 0; i < password_len; i++) {
        key[i % CHACHA20_KEY_SIZE] ^= password[i];
        key[(i + 1) % CHACHA20_KEY_SIZE] ^= (password[i] << 1);
        nonce[i % CHACHA20_NONCE_SIZE] ^= (password[password_len - 1 - i]);
    }
    
    /* Additional mixing */
    for (i = 0; i < 1000; i++) {
        key[i % CHACHA20_KEY_SIZE] ^= key[(i + 7) % CHACHA20_KEY_SIZE];
        nonce[i % CHACHA20_NONCE_SIZE] ^= nonce[(i + 5) % CHACHA20_NONCE_SIZE];
    }
    
    PRINT_HEX("Derived key", key, CHACHA20_KEY_SIZE);
    PRINT_HEX("Derived nonce", nonce, CHACHA20_NONCE_SIZE);
    
    return 0;
}

/**
 * Convert a hexadecimal string to a byte array
 * 
 * @param hex_str   The hexadecimal string
 * @param byte_array The output byte array
 * @param byte_len   The expected length of the byte array
 * @return          0 on success, -1 on failure
 */
int hex_to_bytes(const char *hex_str, uint8_t *byte_array, size_t byte_len) {
    size_t i;
    size_t hex_len;
    
    if (hex_str == NULL || byte_array == NULL) {
        return -1;
    }
    
    hex_len = strlen(hex_str);
    if (hex_len != byte_len * 2) {
        fprintf(stderr, "Error: Hex string length (%zu) doesn't match expected byte length (%zu)\n", 
                hex_len, byte_len);
        return -1;
    }
    
    for (i = 0; i < byte_len; i++) {
        char high_nibble = hex_str[i * 2];
        char low_nibble = hex_str[i * 2 + 1];
        
        /* Convert high nibble */
        if (high_nibble >= '0' && high_nibble <= '9') {
            byte_array[i] = (high_nibble - '0') << 4;
        } else if (high_nibble >= 'A' && high_nibble <= 'F') {
            byte_array[i] = (high_nibble - 'A' + 10) << 4;
        } else if (high_nibble >= 'a' && high_nibble <= 'f') {
            byte_array[i] = (high_nibble - 'a' + 10) << 4;
        } else {
            fprintf(stderr, "Error: Invalid hex character '%c'\n", high_nibble);
            return -1;
        }
        
        /* Convert low nibble */
        if (low_nibble >= '0' && low_nibble <= '9') {
            byte_array[i] |= (low_nibble - '0');
        } else if (low_nibble >= 'A' && low_nibble <= 'F') {
            byte_array[i] |= (low_nibble - 'A' + 10);
        } else if (low_nibble >= 'a' && low_nibble <= 'f') {
            byte_array[i] |= (low_nibble - 'a' + 10);
        } else {
            fprintf(stderr, "Error: Invalid hex character '%c'\n", low_nibble);
            return -1;
        }
    }
    
    return 0;
}

/**
 * Encrypt or decrypt a file using ChaCha20
 * 
 * @param input_file   Path to the input file
 * @param output_file  Path to the output file
 * @param key          256-bit encryption key (32 bytes)
 * @param nonce        96-bit nonce (12 bytes)
 * @param counter      Initial counter value
 * @return             0 on success, non-zero on failure
 */
int process_file(const char *input_file, const char *output_file, 
                const uint8_t *key, const uint8_t *nonce, uint32_t counter) {
    FILE *in = NULL, *out = NULL;
    chacha20_ctx ctx;
    uint8_t buffer[4096], output_buffer[4096];
    size_t read_size;
    int result = 0;
    
    DEBUG_PRINT("Processing file '%s' -> '%s'\n", input_file, output_file);
    PRINT_HEX("Key", key, CHACHA20_KEY_SIZE);
    PRINT_HEX("Nonce", nonce, CHACHA20_NONCE_SIZE);
    DEBUG_PRINT("Counter: %u\n", counter);
    
    /* Open input file */
    in = fopen(input_file, "rb");
    if (in == NULL) {
        perror("Error opening input file");
        return -1;
    }
    
    /* Open output file */
    out = fopen(output_file, "wb");
    if (out == NULL) {
        perror("Error opening output file");
        fclose(in);
        return -1;
    }
    
    /* Initialize ChaCha20 context */
    if (chacha20_init(&ctx, key, nonce, counter) != 0) {
        fprintf(stderr, "Failed to initialize ChaCha20 context\n");
        result = -1;
        goto cleanup;
    }
    
    /* Process the file in chunks */
    while ((read_size = fread(buffer, 1, sizeof(buffer), in)) > 0) {
        if (chacha20_process(&ctx, buffer, output_buffer, read_size) != 0) {
            fprintf(stderr, "ChaCha20 processing failed\n");
            result = -1;
            goto cleanup;
        }
        
        if (fwrite(output_buffer, 1, read_size, out) != read_size) {
            perror("Error writing to output file");
            result = -1;
            goto cleanup;
        }
        
        DEBUG_PRINT("Processed %zu bytes\n", read_size);
    }
    
    if (ferror(in)) {
        perror("Error reading from input file");
        result = -1;
    }
    
cleanup:
    /* Close files */
    if (in != NULL) fclose(in);
    if (out != NULL) fclose(out);
    
    /* Clear sensitive data */
    chacha20_cleanup(&ctx);
    memset(buffer, 0, sizeof(buffer));
    memset(output_buffer, 0, sizeof(output_buffer));
    
    return result;
}

/**
 * Print the usage information for the program
 * 
 * @param program_name The name of the program executable
 */
void print_usage(const char *program_name) {
    printf("ChaCha20 Stream Cipher - RFC 8439 Implementation\n");
    printf("==================================================\n\n");
    printf("Usage:\n");
    printf("  %s                       Run a simple demonstration\n", program_name);
    printf("  %s -e infile outfile     Encrypt a file (password prompt)\n", program_name);
    printf("  %s -d infile outfile     Decrypt a file (password prompt)\n", program_name);
    printf("  %s -x key nonce infile outfile\n", program_name);
    printf("                           Process with explicit key/nonce in hex\n");
    printf("\nWhen using -e/-d options, you will be prompted for a password.\n");
    printf("For -x option:\n");
    printf("  key   = 64-character hex string (32 bytes)\n");
    printf("  nonce = 24-character hex string (12 bytes)\n");
}

int main(int argc, char *argv[]) {
    /* Demo text to encrypt/decrypt */
    const char *demo_text = "ChaCha20 is a stream cipher designed by Daniel J. Bernstein.";
    size_t demo_len = strlen(demo_text);
    
    /* For demonstration, use a fixed key and nonce */
    uint8_t demo_key[CHACHA20_KEY_SIZE] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
    };
    
    uint8_t demo_nonce[CHACHA20_NONCE_SIZE] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01
    };
    
    /* Buffers for the demonstration */
    uint8_t *plaintext = NULL;
    uint8_t *ciphertext = NULL;
    uint8_t *decrypted = NULL;
    
    /* ChaCha20 context */
    chacha20_ctx ctx;
    
    /* For file operations */
    uint8_t key[CHACHA20_KEY_SIZE];
    uint8_t nonce[CHACHA20_NONCE_SIZE];
    char password[128];
    
    int result = 0;
    
    /* Check command line arguments */
    if (argc == 1) {
        /* Run the simple demonstration */
        int i, success = 1;
        
        printf("ChaCha20 Stream Cipher Demonstration\n");
        printf("====================================\n\n");
        
        /* Allocate memory for the demonstration */
        plaintext = (uint8_t *)malloc(demo_len);
        ciphertext = (uint8_t *)malloc(demo_len);
        decrypted = (uint8_t *)malloc(demo_len);
        
        if (!plaintext || !ciphertext || !decrypted) {
            fprintf(stderr, "Memory allocation failed\n");
            result = -1;
            goto cleanup;
        }
        
        /* Copy the demo text to plaintext buffer */
        memcpy(plaintext, demo_text, demo_len);
        
        printf("Original plaintext: %s\n", plaintext);
        PRINT_HEX("Original plaintext (hex)", plaintext, demo_len);
        
        /* Encrypt the plaintext */
        if (chacha20_init(&ctx, demo_key, demo_nonce, 0) != 0) {
            fprintf(stderr, "Failed to initialize ChaCha20 context for encryption\n");
            result = -1;
            goto cleanup;
        }
        
        if (chacha20_process(&ctx, plaintext, ciphertext, demo_len) != 0) {
            fprintf(stderr, "Encryption failed\n");
            result = -1;
            goto cleanup;
        }
        
        printf("\nEncrypted ciphertext (hex): ");
        for (i = 0; i < demo_len; i++) {
            printf("%02x", ciphertext[i]);
            if ((i + 1) % 4 == 0) printf(" ");
        }
        printf("\n");
        
        /* Clean up the context before reusing it */
        chacha20_cleanup(&ctx);
        
        /* Decrypt the ciphertext */
        if (chacha20_init(&ctx, demo_key, demo_nonce, 0) != 0) {
            fprintf(stderr, "Failed to initialize ChaCha20 context for decryption\n");
            result = -1;
            goto cleanup;
        }
        
        if (chacha20_process(&ctx, ciphertext, decrypted, demo_len) != 0) {
            fprintf(stderr, "Decryption failed\n");
            result = -1;
            goto cleanup;
        }
        
        printf("\nDecrypted plaintext: %s\n", decrypted);
        PRINT_HEX("Decrypted plaintext (hex)", decrypted, demo_len);
        
        /* Verify decryption */
        for (i = 0; i < demo_len; i++) {
            if (plaintext[i] != decrypted[i]) {
                success = 0;
                break;
            }
        }
        
        printf("\nVerification: %s\n", success ? "PASSED" : "FAILED");
        
    } else if (argc == 4) {
        /* File encryption/decryption mode with password */
        int encrypt_mode = 0;
        
        if (strcmp(argv[1], "-e") == 0) {
            encrypt_mode = 1;
        } else if (strcmp(argv[1], "-d") == 0) {
            encrypt_mode = 0;
        } else {
            print_usage(argv[0]);
            result = 1;
            goto cleanup;
        }
        
        /* Get password from user */
        printf("Enter password: ");
        if (fgets(password, sizeof(password), stdin) == NULL) {
            fprintf(stderr, "Error reading password\n");
            result = 1;
            goto cleanup;
        }
        
        /* Remove newline character */
        password[strcspn(password, "\n")] = 0;
        
        /* Check if password is empty */
        if (strlen(password) == 0) {
            fprintf(stderr, "Error: Password cannot be empty\n");
            result = 1;
            goto cleanup;
        }
        
        /* Derive key and nonce from password */
        if (derive_key_and_nonce(password, key, nonce) != 0) {
            fprintf(stderr, "Error deriving key and nonce from password\n");
            result = 1;
            goto cleanup;
        }
        
        printf("%s file %s to %s...\n", 
               encrypt_mode ? "Encrypting" : "Decrypting", 
               argv[2], argv[3]);
        
        if (process_file(argv[2], argv[3], key, nonce, 1) == 0) {
            printf("File %s successfully!\n", 
                   encrypt_mode ? "encrypted" : "decrypted");
        } else {
            fprintf(stderr, "File processing failed\n");
            result = 1;
            goto cleanup;
        }
    } else if (argc == 6 && strcmp(argv[1], "-x") == 0) {
        /* File processing with explicit key and nonce */
        const char *key_hex = argv[2];
        const char *nonce_hex = argv[3];
        const char *input_file = argv[4];
        const char *output_file = argv[5];
        
        /* Convert hex strings to bytes */
        if (hex_to_bytes(key_hex, key, CHACHA20_KEY_SIZE) != 0) {
            fprintf(stderr, "Error: Invalid key format\n");
            result = 1;
            goto cleanup;
        }
        
        if (hex_to_bytes(nonce_hex, nonce, CHACHA20_NONCE_SIZE) != 0) {
            fprintf(stderr, "Error: Invalid nonce format\n");
            result = 1;
            goto cleanup;
        }
        
        printf("Processing file %s to %s with explicit key/nonce...\n", 
               input_file, output_file);
        
        if (process_file(input_file, output_file, key, nonce, 1) == 0) {
            printf("File processed successfully!\n");
        } else {
            fprintf(stderr, "File processing failed\n");
            result = 1;
            goto cleanup;
        }
    } else {
        print_usage(argv[0]);
        result = 1;
        goto cleanup;
    }
    
cleanup:
    /* Free allocated memory */
    if (plaintext) {
        memset(plaintext, 0, demo_len);
        free(plaintext);
    }
    if (ciphertext) {
        memset(ciphertext, 0, demo_len);
        free(ciphertext);
    }
    if (decrypted) {
        memset(decrypted, 0, demo_len);
        free(decrypted);
    }
    
    /* Clear sensitive data */
    chacha20_cleanup(&ctx);
    memset(key, 0, CHACHA20_KEY_SIZE);
    memset(nonce, 0, CHACHA20_NONCE_SIZE);
    memset(password, 0, sizeof(password));
    
    return result;
}
```

## File: test/test_compression.c
```cpp
// Test cases for compression
```

## File: test/test_encryption.c
```cpp
// Test cases for encryption
```

## File: .gitignore
```
# Prerequisites
*.d

# Object files
*.o
*.ko
*.obj
*.elf

# Linker output
*.ilk
*.map
*.exp

# Precompiled Headers
*.gch
*.pch

# Libraries
*.lib
*.a
*.la
*.lo

# Shared objects (inc. Windows DLLs)
*.dll
*.so
*.so.*
*.dylib

# Executables
*.exe
*.out
*.app
*.i*86
*.x86_64
*.hex

# Debug files
*.dSYM/
*.su
*.idb
*.pdb

# Kernel Module Compile Results
*.mod*
*.cmd
.tmp_versions/
modules.order
Module.symvers
Mkfile.old
dkms.conf
```

## File: makefile
```
# Directories
SRC_DIR = src
INCLUDE_DIR = include
BUILD_DIR = build
TEST_DIR = test

# Compiler flags
CFLAGS = -Wall -Wextra -pedantic -std=c99 -I$(INCLUDE_DIR)
DEBUG_FLAGS = -DDEBUG -g

# Source files (automatically find all .c files)
ENCRYPTION_SRCS = $(wildcard $(SRC_DIR)/encryption/*.c)
COMPRESSION_SRCS = $(wildcard $(SRC_DIR)/compression/*.c)
SHARING_SRCS = $(wildcard $(SRC_DIR)/sharing/*.c)
UTILS_SRCS = $(wildcard $(SRC_DIR)/utils/*.c)
MAIN_SRC = $(SRC_DIR)/main.c

# Object files
ENCRYPTION_OBJS = $(ENCRYPTION_SRCS:.c=.o)
COMPRESSION_OBJS = $(COMPRESSION_SRCS:.c=.o)
SHARING_OBJS = $(SHARING_SRCS:.c=.o)
UTILS_OBJS = $(UTILS_SRCS:.c=.o)
MAIN_OBJ = $(MAIN_SRC:.c=.o)

# Target executable
TARGET = secure_compress

# Default target
all: $(TARGET)

# Debug build
debug: CFLAGS += $(DEBUG_FLAGS)
debug: all

# Link the final executable
$(TARGET): $(ENCRYPTION_OBJS) $(COMPRESSION_OBJS) $(SHARING_OBJS) $(UTILS_OBJS) $(MAIN_OBJ)
	$(CC) $(CFLAGS) -o $@ $^ -lm

# Compile object files
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Clean build files
clean:
	rm -f $(ENCRYPTION_OBJS) $(COMPRESSION_OBJS) $(SHARING_OBJS) $(UTILS_OBJS) $(MAIN_OBJ) $(TARGET)

# Test target
test: all
	$(CC) $(CFLAGS) -o tests $(TEST_DIR)/*.c $(ENCRYPTION_OBJS) $(COMPRESSION_OBJS) $(SHARING_OBJS) $(UTILS_OBJS) -lm
	./tests
```
